---
title: '开发指南'
---


## 开发流程

### 开发基础

开发笔记插件使用的是React Native框架，所以需要了解React Native的开发知识，相关知识可以在React Native官网上学习。

如果需要开发复杂的插件，那就需要了解Android APK相关的开发知识，相关的知识可以在Android官网上学习。

### Quick Demo

接下来会讲解如何快速开发一个简单的插件Demo，这个Demo会在笔记应用的侧边栏和套索工具条上分别注册一个按钮，点击这两个按钮会展示一张“Hello World”的插件界面。

#### 插件项目创建

插件项目创建很简单，就是创建一个RN项目。

如果之前安装过旧的react-native-cli命令行工具，需要使用以下命令卸载：

```bash wrap
npm uninstall -g react-native-cli
npm uninstall -g react-native
npm uninstall -g react-native-cli
npm uninstall -g react-native
```

再用以下命令重新安装react-native-cli命令行工具：

```bash wrap
npm install -g react-native-cli
npm install -g react-native
npm install -g react-native-cli
npm install -g react-native
```

创建项目用以下命令：

```bash wrap
npx @react-native-community/cli init project_name --template @supernote-plugin/template --version 0.79.2
```

"project_name"是项目名称，可以换成自己创建的项目名称，其他不可替换。当前以项目“plugin”为例创建插件项目，运行命令如下：

![image](/images/devguide/devguide-7.png)

注：插件框架代码使用的RN版本是0.79.2，所以插件项目也得用0.79.2，不能用其他版本，否则插件程序会无法运行

大概几分钟之后会在命令运行目录生成一个“plugin”目录，这就是刚刚创建的插件项目，这个文件夹的目录结构如下：

```text
plugin\
|-- .bundle\\                          # Bundle configuration directory
|   \\-- config
|-- .eslintrc.js                       # ESLint configuration file
|-- .gitignore                         # Git ignore file configuration
|-- .prettierrc.js                     # Prettier code formatting configuration
|-- .watchmanconfig                    # Watchman configuration file
|-- *App.tsx                           # Main application component
|-- Gemfile                            # Ruby dependency management file
|-- README.md                          # Project documentation
|-- __tests__\\                        # Test files directory
|   \\-- App.test.tsx                  # App component test file
|-- *android\\                         # Android platform related files
|   |-- app\\                          # Android application configuration
|   |   |-- build.gradle               # App-level Gradle build file
|   |   |-- debug.keystore             # Debug signing file
|   |   |-- proguard-rules.pro         # ProGuard obfuscation rules
|   |   \\-- src\\                     # Android source code directory
|   |       |-- debug\\                # Debug version configuration
|   |       |   \\-- AndroidManifest.xml
|   |       \\-- main\\                # Main source code
|   |           |-- AndroidManifest.xml
|   |           |-- java\\             # Java/Kotlin source code
|   |           \\-- res\\             # Android resource files
|   |-- build.gradle                   # Project-level Gradle build file
|   |-- gradle\\                       # Gradle Wrapper
|   |   \\-- wrapper\\
|   |       |-- gradle-wrapper.jar
|   |       \\-- gradle-wrapper.properties
|   |-- gradle.properties              # Gradle properties configuration
|   |-- gradlew                        # Gradle Wrapper script (Unix)
|   |-- gradlew.bat                    # Gradle Wrapper script (Windows)
|   \\-- settings.gradle               # Gradle settings file
|-- app.json                           # React Native application configuration
|-- babel.config.js                    # Babel transpiler configuration
|-- buildPlugin.ps1                    # PowerShell build script
|-- buildPlugin.sh                     # Shell build script
|-- *index.js                          # Application entry point
|-- ios\\                              # iOS platform related files
|   |-- .xcode.env                     # Xcode environment configuration
|   |-- Podfile                        # CocoaPods dependency management
|   |-- plugin\\                       # iOS application directory
|   |   |-- AppDelegate.swift          # iOS application delegate
|   |   |-- Images.xcassets\\          # iOS image assets
|   |   |   |-- AppIcon.appiconset\\   # Application icon set
|   |   |   |   \\-- Contents.json
|   |   |   \\-- Contents.json
|   |   |-- Info.plist                 # iOS application info configuration
|   |   |-- LaunchScreen.storyboard    # Launch screen
|   |   \\-- PrivacyInfo.xcprivacy     # Privacy information configuration
|   \\-- plugin.xcodeproj\\            # Xcode project file
|       |-- project.pbxproj            # Project configuration
|       \\-- xcshareddata\\            # Shared data
|           \\-- xcschemes\\           # Build schemes
|               \\-- plugin.xcscheme
|-- jest.config.js                     # Jest testing framework configuration
|-- metro.config.js                    # Metro bundler configuration
|-- package-lock.json                  # npm dependency lock file
|-- *package.json                      # Project dependencies and scripts configuration
\\-- tsconfig.json                     # TypeScript configuration file
```

因为插件是基于React Native编写的，所以这是一个标准的React Native项目结构。以上带星号的文件和目录是插件开发主要会用到的文件目录，这些文件目录用处如下：

index.js：插件的程序入口，后面会讲解这个文件该如何使用

App.tsx：插件的界面入口，后面会讲解这个文件该如何使用

package.json：主要用来添加第三方RN库

android：该目录是存放android本地代码的目录。如果需要开发复杂的插件，比如带Android本地代码和C/C++代码，需要用到该目录来编写android代码和C/C++代码

创建完插件项目就需要导入rtn-supernote-plugin-core，这是插件框架模块库，我司会将相关库上传到npm上，通过以下命令可以添加该模块库。

```bash wrap
yarn add rtn-supernote-plugin-core
```

rtn-supernote-plugin-core库添加完之后就能调用笔记插件的相关API，开发插件功能。可以使用VS Code等代码编辑器打开这个插件项目目录，编写插件代码。

在插件代码中需要import 	'rtn-supernote-plugin-core'库，所有接口都在rtn-supernote-plugin-core库中，只有导入对应的接口和类才能调用插件接口。

#### 插件初始化

插件项目创建完之后会自动生成两个代码文件，index.js和App.tsx。来源是@supernote-plugin/template这个模板类，这个模板类是由我们公司提供的。

先说下index.js文件，这是React Native程序的主入口，也是插件的主入口。插件运行的时候会首先运行index.js代码，所以插件初始化是在这里进行。需要调用PluginManager.init()对插件进行初始化，否则调用其他插件接口会无效，代码如下：

```ts wrap
import { AppRegistry, Image } from 'react-native';
import App from './App';
import { name as appName } from './app.json';
import { PluginManager } from 'rtn-supernote-plugin-core';

AppRegistry.registerComponent(appName, () => App);

PluginManager.init();
```

代码很简单，首先通过 `import { PluginManager } from 'rtn-supernote-plugin-core'` 导入 PluginManager，然后在 AppRegistry.registerComponent 后调用 PluginManager.init 对插件初始化。

其他代码都是在插件项目创建的时候React Native框架自动生成的，主要是通过AppRegistry.registerComponent注册一个插件的界面入口，而入口App对应的就是App.tsx文件。

#### 按钮注册

插件有两种按钮，一种是侧边栏按钮，一种是套索工具条按钮，只有注册了这两种按钮才可以从手写应用进入对应的插件。

##### 侧边栏按钮注册

侧边栏按钮注册需要在index.js中注册，而且得在AppRegistry.registerComponent和PluginManager.init后面，代码如下：

```ts wrap
import { AppRegistry, Image } from 'react-native';
import App from './App';
import { name as appName } from './app.json';
import { PluginManager } from 'rtn-supernote-plugin-core';

AppRegistry.registerComponent(appName, () => App);

PluginManager.init();

PluginManager.registerButton(1, ['NOTE', 'DOC'], {
  id: 100,
  name: 'Side Button',
  icon: Image.resolveAssetSource(
    require('./assets/icon/icon.png'),
  ).uri,
  showType: 1,
});
```

需要先调用PluginManager.init，再调用PluginManager.registerButton注册按钮，需要输入三个参数。

第一个参数是Type，按钮的类型，1：表示侧边栏按钮，2：表示套索工具条按钮，3：表示文档的划词工具条按钮（文档特有按钮，笔记暂时不支持该按钮）。

第二个参数是appTypes，是按钮支持的应用类型，是个数组，有两种类型，NOTE：表示支持笔记应用，DOC：表示支持文档应用。

第三个参数是按钮的属性，数据说明如下：

```text
{
  id：按钮ID，唯一性，定义好之后不可变，插件自己定义
  name: 按钮名称
  icon：按钮图标路径，绝对路径或uri值，可以通过RN官方的Image获取URI路径
  showType：显示类型，0：不显示界面，1：显示界面，默认为1
}
```

如果showType为1，点击按钮之后会在PluginCore中申请一个全屏View，插件界面会显示在该View上。

如果showType为0，则不会显示界面，但是插件后台会收到消息，后台根据点击点击事件运行相应的代码逻辑。

通过上面的方式注册按钮之后就会在笔记的侧边栏显示一个插件按钮，如下图所示：

![image](/images/devguide/devguide-8.png)

上面代码注册的按钮名称为“Side Button”，点开插件图标就会多一个“Side Button”的按钮。

##### 套索工具条按钮注册

套索工具条按钮注册也是调用的PluginManager.registerButton，代码如下：

```ts wrap
import { AppRegistry, Image } from 'react-native';
import App from './App';
import { name as appName } from './app.json';
import { PluginManager } from 'rtn-supernote-plugin-core';

AppRegistry.registerComponent(appName, () => App);

PluginManager.init();

PluginManager.registerButton(1, ['NOTE', 'DOC'], {
  id: 100,
  name: 'Side Button',
  icon: Image.resolveAssetSource(
    require('./assets/icon/icon.png'),
  ).uri,
});

PluginManager.registerButton(2, ['NOTE', 'DOC'], {
  id: 200,
  name: 'Lasso Button',
  icon: Image.resolveAssetSource(
    require('./assets/icon/icon.png'),
  ).uri,
  editDataTypes: [0, 1, 2, 3, 4],
  showType: 1,
});
```

需要将第一个参数的Type改为2，这样就会在套索工具条上注册一个按钮。

第三个参数和侧边栏按钮注册不太一样，数据说明如下：

```text
{
  id：按钮ID，唯一性，定义好之后不可变，插件自己定义
  name: 按钮名称
  icon：按钮图标，绝对路径或uri值，可以通过RN官方的Image获取URI路径
  editDataTypes：当前套索的数据类型数组，只有满足列表内的类型才会在套索工具条上出现对应插件按钮
    0：手写笔迹
    1：标题
    2：图片
    3：文字
    4：链接
    5：几何图形
  showType：显示类型，0：不显示界面，1：显示界面
}
```

相比项目侧边栏按钮多了editDataTypes属性，editDataTypes是数组，可以设置多种数据类型。

根据上面的代码，设置完之后，插件打包安装，套索笔划就会出现“Lasso Button"的按钮，如下图：

![image](/images/devguide/devguide-9.png)

##### 划词按钮注册

该按钮是文档特有的按钮，也是调用PluginManager.registerButton接口，代码如下：

```ts wrap
import { AppRegistry, Image } from 'react-native';
import App from './App';
import { name as appName } from './app.json';
import { PluginManager } from 'rtn-supernote-plugin-core';

AppRegistry.registerComponent(appName, () => App);

PluginManager.init();

PluginManager.registerButton(1, ['NOTE', 'DOC'], {
  id: 100,
  name: 'Side Button',
  icon: Image.resolveAssetSource(
    require('./assets/icon/icon.png'),
  ).uri,
});

PluginManager.registerButton(2, ['NOTE', 'DOC'], {
  id: 200,
  name: 'Lasso Button',
  icon: Image.resolveAssetSource(
    require('./assets/icon/icon.png'),
  ).uri,
  editDataTypes: [0, 1, 2, 3, 4],
  showType: 1,
});

PluginManager.registerButton(3, ['NOTE', 'DOC'], {
  id: 300,
  name: 'Selection Button',
  icon: Image.resolveAssetSource(
    require('./assets/icon/icon.png'),
  ).uri,
  showType: 1,
});
```

需要加第一个参数改为3，就会在文档的划词工具条上注册一个按钮。如下图所示：

![image](/images/devguide/devguide-10.png)

#### 插件界面编写

之前讲过插件项目创建成功后会自动生成两个文件：index.js和App.tsx，index.js是主程序的入口，App.tsx这是插件界面的入口，代码如下：

以上代码在项目创建的时候已经自动生成，如果要改界面也是在这个文件上进行修改。

当前App.tsx是一个很简单的界面，就是在屏幕中间显示“Hello World”字符，背景为白色，界面如下：

![image](/images/devguide/devguide-11.png)

要想显示上面的界面，只需要点击之前注册的“Side Button”或“Lasso Button”按钮就可以了。

### 插件打包

之前讲过插件的简单编写流程，现在讲解怎么将编写的插件打包成插件安装包。

在插件项目创建的时候会自动生成两个命令文件：buildPlugin.ps1和buildPlugin.sh。这两个文件也是从@supernote-plugin/template这个模板库中导入的。插件打包就是在插件项目的根目录的命令行窗口运行这两个命令文件，如下：

Windows 运行以下命令：

```bash wrap
.\buildPlugin.ps1
```

Linux、macOS 运行以下命令：

```bash wrap
./buildPlugin.sh
```

第一次运行插件打包命令会在项目的根目录下生成一个PluginConfig.json文件，内容如下：

```json wrap
{
  "name": "plugin",
  "pluginKey": "plugin",
  "pluginID": "98blcl1mp5fxamrm",
  "iconPath": "",
  "desc": "",
  "versionCode": "1",
  "versionName": "0.0.1",
  "jsMainPath": "index"
}
```

这是一个插件配置文件，第一次运行打包命令才会生成，之后不会再生成该文件，后续需要用户手动修改该文件的内容。PluginConfig.json的各个字段的解析如下：

name：插件名称，可以手动修改

pluginKey：插件的key值，需要和AppRegistry.registerComponent中的appkey保持一致，否则插件无法运行

pluginID：插件ID，唯一ID，区分不同的插件。由打包命令随机生成，一旦生成不能修改，否则安装更改后的插件会出现第二个同样功能的插件

iconPath：插件图标路径，是相对项目根目录的路径，需要用户手动填写。

versionCode：插件版本号

versionName：插件版本名称

desc：插件功能描述

jsMainPath：插件入口，填写的是插件程序入口文件名，这里是“index”，最好不要修改。

author：插件作者，该字段需要用户自行添加，打包命令不会自动生成。

打包命令运行完之后还会生成一个build目录，目录结构如下：

```text
build/
├── generated/
│   ├── PluginConfig.json
│   ├── drawable-mdpi/
│   │   └── assets_icon_icon.png
│   └── plugin.bundle
└── outputs/
    └── plugin.snplg
```

generated目录内存放的是插件打包时生成的文件，最终会将这些文件打包进build\outputs\plugin.snplg这个插件安装包中。

### 插件安装

插件安装很简单，将上一节的插件包拷贝进SuperNote设备的MyStyle目录下。然后打开“设置->应用->管理插件”界面，如下图：

![image](/images/devguide/devguide-12.png)

然后点击右上角的“+”号，选择需要安装的插件包安装点击安装，如下图：

![image](/images/devguide/devguide-13.png)

安装完成之后，会在手写应用的侧边工具栏和套索工具栏上显示已安装插件注册的按钮，按钮显示的位置之前3.2.3节已经讲过，这里不再赘述。

## 功能开发

### Trail

所有展示在手写应用（笔记、文档）上的数据都是一个Trail对象，包含普通手写笔划、标题、链接、文本框、五角星、几何图形。所以要开发好一个创建就需要明白这个Trail对象是什么？以下是Trail对象数据格式：

```
class Trail { public uuid: string; // 通用唯一识别码 public type: number = 0;//笔划类型 public pageNum: number = 0; // Trail所在的页码 public layerNum: number = 0; // trail所在的图层 public thickness: number = 0; // 笔划粗细 // 识别结果数据 public recognizeResult: RecogResultData = new RecogResultData(); public maxX: number = 0; // 最大坐标值 public maxY: number = 0; // 最大坐标值 /** * 角度数据 * 因为获取的角度数据量可能会很大，所以数据都是存在android本地缓存中，在RN端是一个TrailDataAccessor<Point[]>类， * {@link TrailDataAccessor<Point[]>}这个类可以访问Android本地缓存数据，只有通过TrailDataAccessor才能获取角度数据，其他方式无法访问 */ public angles: TrailDataAccessor<Point> = new TrailDataAccessor<Point>("", TrailPointDataType.ANGLE_POINT, 'point'); public trailStatus: number = 0; // Trail状态 public trailNumInPage: number = 0; // 在页中的笔迹号,在该页中笔划的唯一标志,从0开始，一旦赋值不能更改 /** * 轮廓点,非必要参数，修改可以不传，标题得传 * 因为获取的轮廓点数据量会很大，所以数据都是存在android本地缓存中，在RN端是一个TrailDataAccessor<Point[]>类， * {@link TrailDataAccessor<Point[]>}这个类可以访问Android本地缓存数据，只有通过TrailDataAccessor才能获取轮廓点数据，其他方式无法访问 */ public contoursSrc: TrailDataAccessor<Point[]> = new TrailDataAccessor<Point[]>("", TrailPointDataType.CONTOUR_POINT, 'pointArray'); public link: LinkTrail | null = null; // 链接数据，不是链接类型不会有该数据 public title: TitleTrail | null = null; // 标题数据，不是标题类型不会有该数据 public textBox: TextBox | null = null; // 文本框数据，不是文本框类型不会有该数据 public stroke: Stroke | null = null; // 笔划数据，不是笔划类型不会有该数据 public geometry: Geometry | null = null; // 几何图形数据，不是几何图形类型不会有该数据 public fiveStar: FiveStar | null = null; // 五角星数据，不是五角星类型不会有该数据 /** * 回收该Trail数据，释放Native缓存数据 */ public async recycle(): Promise<void> { NativeCommAPIModule.recycleTrail(this.uuid); this.angles?.clearCache(); this.contoursSrc?.clearCache(); }}class Trail { public uuid: string; // 通用唯一识别码 public type: number = 0;//笔划类型 public pageNum: number = 0; // Trail所在的页码 public layerNum: number = 0; // trail所在的图层 public thickness: number = 0; // 笔划粗细 // 识别结果数据 public recognizeResult: RecogResultData = new RecogResultData(); public maxX: number = 0; // 最大坐标值 public maxY: number = 0; // 最大坐标值 /** * 角度数据 * 因为获取的角度数据量可能会很大，所以数据都是存在android本地缓存中，在RN端是一个TrailDataAccessor<Point[]>类， * {@link TrailDataAccessor<Point[]>}这个类可以访问Android本地缓存数据，只有通过TrailDataAccessor才能获取角度数据，其他方式无法访问 */ public angles: TrailDataAccessor<Point> = new TrailDataAccessor<Point>("", TrailPointDataType.ANGLE_POINT, 'point'); public trailStatus: number = 0; // Trail状态 public trailNumInPage: number = 0; // 在页中的笔迹号,在该页中笔划的唯一标志,从0开始，一旦赋值不能更改 /** * 轮廓点,非必要参数，修改可以不传，标题得传 * 因为获取的轮廓点数据量会很大，所以数据都是存在android本地缓存中，在RN端是一个TrailDataAccessor<Point[]>类， * {@link TrailDataAccessor<Point[]>}这个类可以访问Android本地缓存数据，只有通过TrailDataAccessor才能获取轮廓点数据，其他方式无法访问 */ public contoursSrc: TrailDataAccessor<Point[]> = new TrailDataAccessor<Point[]>("", TrailPointDataType.CONTOUR_POINT, 'pointArray'); public link: LinkTrail | null = null; // 链接数据，不是链接类型不会有该数据 public title: TitleTrail | null = null; // 标题数据，不是标题类型不会有该数据 public textBox: TextBox | null = null; // 文本框数据，不是文本框类型不会有该数据 public stroke: Stroke | null = null; // 笔划数据，不是笔划类型不会有该数据 public geometry: Geometry | null = null; // 几何图形数据，不是几何图形类型不会有该数据 public fiveStar: FiveStar | null = null; // 五角星数据，不是五角星类型不会有该数据 /** * 回收该Trail数据，释放Native缓存数据 */ public async recycle(): Promise<void> { NativeCommAPIModule.recycleTrail(this.uuid); this.angles?.clearCache(); this.contoursSrc?.clearCache(); }}
```

以上是Trail对象的数据格式，具体作用在注释中已经描述。Trail主要有以下类型：

```
还需要注意angles和contoursSrc这两个成员变量，一个存的是角度数据，是一个Point数组数据，另一个存的是轮廓点数据，是一个Point[]数组数据。这两个数据都有可能会很大量，如果直接穿给插件耗时可能会很长，所以在插件端只有持有该数据的引用，实际是存储在Android端。而TrailDataAccessor就是对应的引用对象，数据结构如下：
TrailDataAccessor<T extends Point | number | boolean | Point[] | RecognData> { private uuid: string = ""; private type: number = -1; private _size: number = -1; private cache: Map<number, T> = new Map(); private cacheRanges: Array<{ start: number, end: number }> = []; private dataType: 'point' | 'number' | 'boolean' | 'pointArray' | 'recognData'; constructor(uuid: string, type: number, dataType: 'point' | 'number' | 'boolean' | 'pointArray' | 'recognData') { console.log('TrailDataAccessor constructor uuid:', uuid); this.uuid = uuid; this.type = type; this.dataType = dataType; } /** * 获取数据长度 */ async size(): Promise<number> { if (this._size === -1) { const result = await NativeCommAPIModule.opTrailPointData(this.uuid, this.type, TrailPointOperationType.GET_LIST_SIZE, [], [], [] ); if (result) { this._size = result as number; } } return this._size; } /** * 获取指定索引的数据 * @param index 索引位置 */ async get(index: number): Promise<T | null> { // 先检查缓存 if (this.cache.has(index)) { console.log("TrailDataAccessor get cache", index, this.cache.get(index)); return this.cache.get(index)!; } // 从原生端获取数据 const data = await NativeCommAPIModule.opTrailPointData(this.uuid, this.type, TrailPointOperationType.GET_POINT_BY_INDEX, [index], [], [] ) as T[]; console.log("TrailDataAccessor get", index, data); if (data?.length > 0) { const item = data[0]; console.log("TrailDataAccessor get data", index, item); if (this.isValidData(item)) { this.cache.set(index, item); return item; } } return null; } /** * 批量获取数据 * @param startIndex 起始索引 * @param count 获取数量 */ async getRange(startIndex: number, count: number): Promise<T[]> { // 检查是否已缓存该范围 const isCached = this.cacheRanges.some(range => startIndex >= range.start && startIndex + count <= range.end ); if (isCached) { const result: T[] = []; for (let i = startIndex; i < startIndex + count; i++) { const cachedValue = this.cache.get(i); if (cachedValue !== undefined) { result.push(cachedValue); } } return result; } // 从原生端批量获取 const data = await NativeCommAPIModule.opTrailPointData(this.uuid, this.type, TrailPointOperationType.GET_POINT_BY_INDEX, [startIndex, startIndex + count - 1], [], [] ) as T[]; if (data?.length > 0) { // 更新缓存 data.forEach((item, index) => { if (this.isValidData(item)) { this.cache.set(startIndex + index, item); } }); this.cacheRanges.push({ start: startIndex, end: startIndex + count }); return data.filter(item => this.isValidData(item)); } return []; } /** * 遍历所有数据（支持异步迭代器） */ async *[Symbol.asyncIterator](): AsyncIterableIterator<T> { const totalSize = await this.size(); for (let i = 0; i < totalSize; i++) { const item = await this.get(i); if (item !== null) { yield item; } } } /** * 添加数据到指定位置 * @param index 插入位置 * @param value 要添加的数据 */ async add(index: number, value: T): Promise<boolean> { const valueArray = [value] as unknown as Object[]; const result = await NativeCommAPIModule.opTrailPointData(this.uuid, this.type, TrailPointOperationType.INSERT_POINT_AT_INDEX, [index], [], valueArray ); if (result) { // 清除缓存，因为数据结构已改变 this.clearCache(); this._size = -1; // 重置大小缓存 return true; } return false; } /** * 批量设置数据 * @param index 起始索引 * @param endIndex 结束索引 * @param valueArray 要设置的数据数组 */ async setRange(index: number, endIndex: number, valueArray: T[]): Promise<boolean> { console.log("TrailDataAccessor setRange", index, endIndex); const newValues = valueArray as unknown as Object[]; const result = await NativeCommAPIModule.opTrailPointData(this.uuid, this.type, TrailPointOperationType.REPLACE_POINT_AT_INDEX, [index, endIndex], [], newValues ); console.log("TrailDataAccessor set result", index, result); if (result) { // 清除缓存，因为数据结构已改变 this.clearCache(); this._size = -1; // 重置大小缓存 return true; } return false; } /** * 设置指定索引的数据 * @param index 索引位置 * @param value 要设置的数据 */ async set(index: number, value: T): Promise<boolean> { console.log("TrailDataAccessor set", index, value); const valueArray = [value] as unknown as Object[]; const result = await NativeCommAPIModule.opTrailPointData(this.uuid, this.type, TrailPointOperationType.REPLACE_POINT_AT_INDEX, [index], [], valueArray ); console.log("TrailDataAccessor set result", index, result); if (result) { // 清除缓存，因为数据结构已改变 this.clearCache(); this._size = -1; // 重置大小缓存 return true; } return false; } /** * 清除缓存 */ clearCache(): void { this.cache.clear(); this.cacheRanges = []; } /** * 获取缓存统计信息 */ getCacheStats(): { cachedCount: number, totalSize: number } { return { cachedCount: this.cache.size, totalSize: this._size }; } /** * 预加载指定范围的数据到缓存 * @param startIndex 起始索引 * @param count 加载数量 */ async preload(startIndex: number, count: number): Promise<void> { await this.getRange(startIndex, count); } /** * 检查指定索引是否已缓存 * @param index 索引位置 */ isCached(index: number): boolean { return this.cache.has(index); } /** * 验证数据是否有效 * @param data 要验证的数据 */ private isValidData(data: any): data is T { if (this.dataType === 'number') { return typeof data === 'number'; } else if (this.dataType === 'boolean') { return typeof data === 'boolean'; } else if (this.dataType === 'pointArray') { return Array.isArray(data) && data.every(item => item && typeof item === 'object' && 'x' in item && 'y' in item ); } else if (this.dataType === 'recognData') { return data && typeof data === 'object' && 'X' in data && 'Y' in data && 'Flag' in data && 'timestamp' in data && typeof data.X === 'number' && typeof data.Y === 'number' && typeof data.Flag === 'number' && typeof data.timestamp === 'number'; } else { return data && typeof data === 'object' && 'x' in data && 'y' in data; } }}TrailDataAccessor<T extends Point | number | boolean | Point[] | RecognData> { private uuid: string = ""; private type: number = -1; private _size: number = -1; private cache: Map<number, T> = new Map(); private cacheRanges: Array<{ start: number, end: number }> = []; private dataType: 'point' | 'number' | 'boolean' | 'pointArray' | 'recognData'; constructor(uuid: string, type: number, dataType: 'point' | 'number' | 'boolean' | 'pointArray' | 'recognData') { console.log('TrailDataAccessor constructor uuid:', uuid); this.uuid = uuid; this.type = type; this.dataType = dataType; } /** * 获取数据长度 */ async size(): Promise<number> { if (this._size === -1) { const result = await NativeCommAPIModule.opTrailPointData(this.uuid, this.type, TrailPointOperationType.GET_LIST_SIZE, [], [], [] ); if (result) { this._size = result as number; } } return this._size; } /** * 获取指定索引的数据 * @param index 索引位置 */ async get(index: number): Promise<T | null> { // 先检查缓存 if (this.cache.has(index)) { console.log("TrailDataAccessor get cache", index, this.cache.get(index)); return this.cache.get(index)!; } // 从原生端获取数据 const data = await NativeCommAPIModule.opTrailPointData(this.uuid, this.type, TrailPointOperationType.GET_POINT_BY_INDEX, [index], [], [] ) as T[]; console.log("TrailDataAccessor get", index, data); if (data?.length > 0) { const item = data[0]; console.log("TrailDataAccessor get data", index, item); if (this.isValidData(item)) { this.cache.set(index, item); return item; } } return null; } /** * 批量获取数据 * @param startIndex 起始索引 * @param count 获取数量 */ async getRange(startIndex: number, count: number): Promise<T[]> { // 检查是否已缓存该范围 const isCached = this.cacheRanges.some(range => startIndex >= range.start && startIndex + count <= range.end ); if (isCached) { const result: T[] = []; for (let i = startIndex; i < startIndex + count; i++) { const cachedValue = this.cache.get(i); if (cachedValue !== undefined) { result.push(cachedValue); } } return result; } // 从原生端批量获取 const data = await NativeCommAPIModule.opTrailPointData(this.uuid, this.type, TrailPointOperationType.GET_POINT_BY_INDEX, [startIndex, startIndex + count - 1], [], [] ) as T[]; if (data?.length > 0) { // 更新缓存 data.forEach((item, index) => { if (this.isValidData(item)) { this.cache.set(startIndex + index, item); } }); this.cacheRanges.push({ start: startIndex, end: startIndex + count }); return data.filter(item => this.isValidData(item)); } return []; } /** * 遍历所有数据（支持异步迭代器） */ async *[Symbol.asyncIterator](): AsyncIterableIterator<T> { const totalSize = await this.size(); for (let i = 0; i < totalSize; i++) { const item = await this.get(i); if (item !== null) { yield item; } } } /** * 添加数据到指定位置 * @param index 插入位置 * @param value 要添加的数据 */ async add(index: number, value: T): Promise<boolean> { const valueArray = [value] as unknown as Object[]; const result = await NativeCommAPIModule.opTrailPointData(this.uuid, this.type, TrailPointOperationType.INSERT_POINT_AT_INDEX, [index], [], valueArray ); if (result) { // 清除缓存，因为数据结构已改变 this.clearCache(); this._size = -1; // 重置大小缓存 return true; } return false; } /** * 批量设置数据 * @param index 起始索引 * @param endIndex 结束索引 * @param valueArray 要设置的数据数组 */ async setRange(index: number, endIndex: number, valueArray: T[]): Promise<boolean> { console.log("TrailDataAccessor setRange", index, endIndex); const newValues = valueArray as unknown as Object[]; const result = await NativeCommAPIModule.opTrailPointData(this.uuid, this.type, TrailPointOperationType.REPLACE_POINT_AT_INDEX, [index, endIndex], [], newValues ); console.log("TrailDataAccessor set result", index, result); if (result) { // 清除缓存，因为数据结构已改变 this.clearCache(); this._size = -1; // 重置大小缓存 return true; } return false; } /** * 设置指定索引的数据 * @param index 索引位置 * @param value 要设置的数据 */ async set(index: number, value: T): Promise<boolean> { console.log("TrailDataAccessor set", index, value); const valueArray = [value] as unknown as Object[]; const result = await NativeCommAPIModule.opTrailPointData(this.uuid, this.type, TrailPointOperationType.REPLACE_POINT_AT_INDEX, [index], [], valueArray ); console.log("TrailDataAccessor set result", index, result); if (result) { // 清除缓存，因为数据结构已改变 this.clearCache(); this._size = -1; // 重置大小缓存 return true; } return false; } /** * 清除缓存 */ clearCache(): void { this.cache.clear(); this.cacheRanges = []; } /** * 获取缓存统计信息 */ getCacheStats(): { cachedCount: number, totalSize: number } { return { cachedCount: this.cache.size, totalSize: this._size }; } /** * 预加载指定范围的数据到缓存 * @param startIndex 起始索引 * @param count 加载数量 */ async preload(startIndex: number, count: number): Promise<void> { await this.getRange(startIndex, count); } /** * 检查指定索引是否已缓存 * @param index 索引位置 */ isCached(index: number): boolean { return this.cache.has(index); } /** * 验证数据是否有效 * @param data 要验证的数据 */ private isValidData(data: any): data is T { if (this.dataType === 'number') { return typeof data === 'number'; } else if (this.dataType === 'boolean') { return typeof data === 'boolean'; } else if (this.dataType === 'pointArray') { return Array.isArray(data) && data.every(item => item && typeof item === 'object' && 'x' in item && 'y' in item ); } else if (this.dataType === 'recognData') { return data && typeof data === 'object' && 'X' in data && 'Y' in data && 'Flag' in data && 'timestamp' in data && typeof data.X === 'number' && typeof data.Y === 'number' && typeof data.Flag === 'number' && typeof data.timestamp === 'number'; } else { return data && typeof data === 'object' && 'x' in data && 'y' in data; } }}
```

需要注意的是，所有对角度和轮廓点的操作，都需要通过TrailDataAccessor中的函数，比如获取数量值（size函数），获取指定的索引数据（get函数），每个函数上面都有注释，这里不再赘述。

除此之外还需要注意回收Trail对象，因为Trail对象实际是存在在Android端，如果不回收会一直存在，可以调用Trail中的recycle方法回收，也可以调用PluginCommAPI.recycleTrail回收指定的Trail对象。

之前说过Trail有不同的笔划类型，除了共有的属性，每种类型都有其特有的属性，接下来讲解每种类型的特有属性。

标题

标题的数据结构如下：

```
class TitleTrail { public X: number = 0; public Y: number = 0; public width: number = 0; public height: number = 0; public page: number = 0;// 标题的当前页码 public num: number = 0; // 标题在所在页码的序号 public index: number = 0; // 导出用，所有标题的index // 页码顺序 // public pageSeq: number = 0; /** * 标题样式映射表 * 0：去掉标题属性 * 1：黑底标题 * 2：灰白标题 * 3：灰黑标题 * 4：阴影标题 */ public style: number = 0; //笔划编号列表，如果是笔划标题，表示当前页那些笔划是该标题的 public controlTrailNums: number[] = [];}class TitleTrail { public X: number = 0; public Y: number = 0; public width: number = 0; public height: number = 0; public page: number = 0;// 标题的当前页码 public num: number = 0; // 标题在所在页码的序号 public index: number = 0; // 导出用，所有标题的index // 页码顺序 // public pageSeq: number = 0; /** * 标题样式映射表 * 0：去掉标题属性 * 1：黑底标题 * 2：灰白标题 * 3：灰黑标题 * 4：阴影标题 */ public style: number = 0; //笔划编号列表，如果是笔划标题，表示当前页那些笔划是该标题的 public controlTrailNums: number[] = [];}
```

以上是标题的详细数据结构，数据结构比较简单，每个参数的作用可以看上面的注释。

链接

链接的数据结构如下：

```
class LinkTrail { /** * 链接种类，0表示文字链接，1表示笔划链接 */ public category: number = 0; public X: number = 0; // 链接左上角坐标X轴值 public Y: number = 0; // 链接左上角坐标Y轴值 public width: number = 0; // 链接的宽度 public height: number = 0; // 链接的高度 public page: number = 0;// 链接的当前页码 public num: number = 0; // 链接在所在页码的序号 public index: number = 0; // 导出用，所有链接的index /** * 链接样式 * 0：实下划线 * 1：实边框 * 2：虚边框 */ public style: number = 0; /// 链接类型 file folder png url等，需要一一对应否则会无效 /// 0 跳转到笔记页 /// 1笔记文件 /// 2是文档 /// 3是图片 /// 4是网址 /// 5是其他 /// 6摘录链接会跳转到摘录 public linkType: number = 0; public destPath: string = "";// 目标文件路径，如果是url，则对应的是网页地址 public destPage: number = 0; // 链接跳转到目标页码，只有linkType为0时有效 // 以下为文字链接新增属性 public fontSize: number = 0;// 字体大小 public fullText: string = ""; // 全部文字内容 public showText: string = ""; // 显示文字内容 public italic: number = 1; // 笔划编号列表，如果是笔划链接，表示当前页那些笔划是该链接的，文字链接不需要传这个值，笔划链接需要传这个值 public controlTrailNums: number[] = [];}class LinkTrail { /** * 链接种类，0表示文字链接，1表示笔划链接 */ public category: number = 0; public X: number = 0; // 链接左上角坐标X轴值 public Y: number = 0; // 链接左上角坐标Y轴值 public width: number = 0; // 链接的宽度 public height: number = 0; // 链接的高度 public page: number = 0;// 链接的当前页码 public num: number = 0; // 链接在所在页码的序号 public index: number = 0; // 导出用，所有链接的index /** * 链接样式 * 0：实下划线 * 1：实边框 * 2：虚边框 */ public style: number = 0; /// 链接类型 file folder png url等，需要一一对应否则会无效 /// 0 跳转到笔记页 /// 1笔记文件 /// 2是文档 /// 3是图片 /// 4是网址 /// 5是其他 /// 6摘录链接会跳转到摘录 public linkType: number = 0; public destPath: string = "";// 目标文件路径，如果是url，则对应的是网页地址 public destPage: number = 0; // 链接跳转到目标页码，只有linkType为0时有效 // 以下为文字链接新增属性 public fontSize: number = 0;// 字体大小 public fullText: string = ""; // 全部文字内容 public showText: string = ""; // 显示文字内容 public italic: number = 1; // 笔划编号列表，如果是笔划链接，表示当前页那些笔划是该链接的，文字链接不需要传这个值，笔划链接需要传这个值 public controlTrailNums: number[] = [];}
```

链接主要分两种，笔划链接和文字链接。笔划链接不会有文字信息，但是有个笔划编号数据，也就是controlTrailNums，这个数组表示哪些笔划被设置为了链接。文字链接不会有笔划编号数据，但是会有文字信息，比如文字内容，字体大小等信息。

文本框

文本框的数据结构如下：

### 标题

标题只有笔记应用才拥有该功能，其他手写应用（文档）不支持该该功能，也无法调用相关接口。
